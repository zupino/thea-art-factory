1. Install Open Zeppelin, which provides audited interface file
   for some useful smart contract standards like ERC20 and ERC721

    npm install @openzeppelin/contracts

2. Reference to the ERC721 standard, from OpenZeppelin

    https://docs.openzeppelin.com/contracts/2.x/erc721
    https://eips.ethereum.org/EIPS/eip-721

 Main takeaway: The ERC721 inheriting contract is keeping track of
 all the token generated by it (in fact in our case it is called
 Thea's Art Factory). Each piece of art (each token) is uniquelly
 identified by a uint256 id.

3. Truffle main cycle

    3.0 `truffle init` to initialize the workspace. `truffle-config.json` should be aligned with
        local ganache configuration.
    3.1 Run ganache for local blockchain, Thea's Art Factory is the workspace
    3.2 In case you make changes, delete ./build folder to clean the contract builds
    3.3 `truffle compile` to compile contracts after changes
    3.4 `truffle migrate` to deploy on local blockchain
    3.5 `truffle console` for basic contract iteraction

    Migration scripts allow to deploy artifacts in a specific order and re-used deployment info.
    In our case, for example, we first deploy an ERC721Full (Artwork) and then an ArtFactory
    initialized with the address of the Artwork.

    This follows the model of Thisartworkisalwaysonsale, but I will change it as I need to have
    the ArtFactory to handle more than one Artwork.

4. Contract interaction via `truffle console`

    4.1 create a contract object to easily interact

            `const artf = await Artwork.new()`

    4.2 To have them handy, get the local workspace accounts

            `let accounts = await web3.eth.getAccounts()`

    4.3 Remember there is the implicit last parameter you can
        always pass to contract function calls/transactions, e.g.

            artf.createNewArtwork("0xaddr", "http:metadata.com/1", {from: accounts[1], value: 4000})

        in this example we can change the calling address and the amount sent.


Notes about testing

1. In case the truffle-config.js does not explicitly specify a network, the `truffle test`
command will hang forever. Workaround is to un-comment the development network
from truffle-config.js. See https://github.com/trufflesuite/truffle/issues/1976

2. In assert() statement to not include methods call, but get the
    method returned value first with `await` call, then use the variable in
    assert statement. I.e.:

        not
            assert.equal(instance.name(), "Expected name", "Name do not match")
        but
            let name = await instance.name();
            assert.equal(name, "Expected name", "Name do not match")



			LAST TIME LEFT 

			New model is actually having no modification to the OZ ERC721 files, 
			simply create a new Artwork contract which derives from ERC721, 
			ERC721Metadata and ERC721Enumerable (same as ERC721Full).

			Seems cleaner, but still need to verify all the cases can still be supported

               SECOND-LAST TIME LEFT:

                15.03.2020 Update

                General understanding:
                - Artwork (ERC721Full) is deployed indipendently
                - ArtFactory is initialized with `artist` and `artwork` address
                - During initialization of ArtFactory, artwork.setup() is called, and _mint() happens
                - caller of ERC721Full.setup() is ArtFactory contract, so this is the steward address
                - steward is the owner of the minted token

                Limitations
                - only 1 token can be minted with this approach
                - ERC721 standard implementation requires 2 modifications
                    - ERC721Full.sol > setup method
                    - ERC721.sol > address steward and init boolean, plus modified isApprovedOrOwner()

                Next Steps

                I believe using ERC721Enumerable and allToken mapping, we can handle more tokens
                with the same ArtFactory, the advantage is that we do not need new contract
                deployed for each artwork, but we can have the artist create new one via contract
                transactions.

References

1.  How Ethereum address are created
    https://medium.com/@jeancvllr/solidity-tutorial-all-about-addresses-ffcdf7efc4e7

